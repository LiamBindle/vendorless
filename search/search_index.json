{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Vendorless is a Python-based templating engine for rendering Docker Compose projects. In vendorless, blueprints are Python modules that configures the services that make up an application, like databases and servers.  A blueprint can be rendered to Docker Compose files that run an instance of the application.  The basic functionality of vendorless is provided by the <code>vendorless.core</code> package, and other packages provide specific service templates and blueprints. For example, the <code>vendorless.postgres</code> package provides service templates for running a PostGreSQL database, and the <code>vendorless.keycloak</code> package provides a blueprint for running a Keycloak authentication server (which uses service templates provided by <code>vendorless.postgres</code>).</p> <p>The goal of vendorless is to make it easier to build your application's backbone using free and open-source services.  Vendorless is designed for small- to medium-sized projects that value self-containment over infinite scalability, and pragmatic tooling that prioritizes development efficency, and maintainability. </p>"},{"location":"#key-features","title":"Key Features","text":"<ol> <li>Python-based infrastructure-as-code (IaC). Blueprints are Python modules, which allows of the use of complex scriping, looping, and logic to configure service templates.  </li> <li>Parameter linking allows the outputs of one service template to be linked to the inputs of other service templates. Service templates are effectively black boxes that are configured via their input parameters. Service templates also have output parameters, and these output parameters (e.g., ports, URLs, file paths, service names) can be linked to the input parameters of other service templates.</li> <li>Extensibility is provided by namespace packaging. Vendorless packages provide service templates (for use in blueprints), CLI commands (e.g., key generation), and/or blueprints (ready-made applications). You can leverage community maintained packages, or create your own. </li> </ol>"},{"location":"#commands","title":"Commands","text":"<p><code>vl</code> is an extensible command-line tool that runs commands from vendorless packages. The functionality for working with vendorless blueprints and packages is provided by <code>vendorless.core</code> which includes:</p> <ol> <li>Rendering blueprints</li> <li>Developing new vendorless packages (creating, documenting, testing, and publishing)</li> </ol> <p>Vendorless packages may add additional commands that are related to the package's services (e.g., key generation, certificate generation, secret generation, etc.).</p> <p>The format of <code>vl</code> commands is</p> <pre><code>vl &lt;package&gt; &lt;command&gt; &lt;arguments&gt;...\n</code></pre> <p>where <code>&lt;package&gt;</code> is the vendorless package (e.g., <code>core</code>) that provides <code>&lt;command&gt;</code>. For example:</p> <pre><code>$ vl core render -m vendorless.keycloak.blueprints.auth_server\n</code></pre> <p>You can always use <code>--help</code> to see command documentation.</p>"},{"location":"#commands-via-docker","title":"Commands via Docker","text":"<p>You can run vendorless commands via docker like so:</p> <pre><code>docker run ghcr.io/liambindle/vendorless:latest \\\n    vendorless.&lt;packages&gt;... \\\n    &lt;package&gt; &lt;command&gt; &lt;arguments&gt;...\n</code></pre> <p>This is useful if you're running vendorless in an environment that doesn't have Python (e.g., a production server). The first set of arguments (packages prefixed with <code>vendorless.</code>) is the list of vendorless packages that need to be installed. The subsequent arguments are the arguments to the <code>vl</code> command. For example</p> <pre><code>$ docker run ghcr.io/liambindle/vendorless:latest \\\n    vendorless.core vendorless.keycloak \\\n    core render -m vendorless.keycloak.blueprints.auth_server\n</code></pre>"},{"location":"blueprints/","title":"Blueprints","text":""},{"location":"blueprints/#vendorless.core.Volume","title":"<code>vendorless.core.Volume</code>","text":"<p>               Bases: <code>ServiceTemplate</code></p> <p>Represents a Docker volume configuration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the Docker volume.</p> Source code in <code>src/vendorless/core/volume.py</code> <pre><code>@dataclass\nclass Volume(ServiceTemplate):\n    \"\"\"\n    Represents a Docker volume configuration.\n    \"\"\"\n\n    name: str = parameter()\n    \"\"\"The name of the Docker volume.\"\"\"\n\n    def _template_list(self) -&gt; list[tuple[str, str]]:\n        return [\n            ('volume/docker-compose.yaml', 'docker-compose.yaml')\n        ]\n</code></pre>"},{"location":"blueprints/#vendorless.core.Volume.name","title":"<code>name = parameter()</code>","text":"<p>The name of the Docker volume.</p>"},{"location":"creating-packages/","title":"Creating Packages","text":"<p>Packages can provide blueprints, service templates, and/or commands. This page will demonstrate creating a vendorless package for a PostGreSQL database. This is a simple example that will demonstrate the general workflow.</p>"},{"location":"creating-packages/#setup","title":"Setup","text":"<p>The command <code>vl core package new</code> is used to create a new package. The command will prompt you for some basic information about the package that you are creating. The package will be preconfigured with the right structure, documentation, tests, and GitHub actions for CI.  If you have installed <code>vendorless.core</code> via <code>pip</code> you can run the <code>vl</code> command directly, or you can run it via docker.</p> <pre><code>$ docker run ghcr.io/liambindle/vendorless:latest \\\n    vendorless.core \\\n    core package new\nname:               postgres\nversion:\ndescription:        PostgreSQL database\nauthor:             Liam Bindle\nemail:              liam.bindle@gmail.com\ngithub_username:    LiamBindle\nlicense:      \n</code></pre> <p>Then you can run <code>poetry install</code> to install your newly created package.</p> <pre><code>$ cd vendorless.postgres\n$ poetry install\n</code></pre>"},{"location":"creating-packages/#blueprints","title":"Blueprints","text":"<p>A blueprint is the Python module (.py file) that is used by <code>vl core render</code> to render the Docker Compose files that stand up and application. Blueprints should go in <code>vendorless.&lt;package&gt;.blueprints</code> where <code>&lt;package&gt;</code> is the your package.</p> <pre><code># vendorless.postgres.blueprints.basic_database\n\nfrom vendorless.postgres import PostGreSQLDatabase\nfrom vendorless.core import Volume\n\nvolume = Volume(\n    ...\n)\n\npg_databasn = PostGreSQLDatabase(\n    ...\n)\n</code></pre>"},{"location":"creating-packages/#service-templates","title":"Service Templates","text":"<p>Service templates are black boxes that are configure services. They are effectively black boxes with input parameters that configure the service, and output parameters that can linked to the inputs of other service templates. This parameter linking is useful to ensure that things like ports, urls, service names, etc. are connected properly between services.</p> <p>You can put service templates anywhere, but your top-level <code>__init__.py</code> file should import all of the service templates that your package provides. Below is an example of creating a service template for a PostGreSQL database in a file called service_templates.py.</p> <pre><code># vendorless.postgres.service_templates.py\n\nfrom dataclasses import dataclass\nfrom vendorless.core import Blueprint, parameter, computed_parameter, Volume\n\n@dataclass\nclass PostGreSQLDatabase(Blueprint):\n    volume_name: str = parameter()             # required because no default\n    data_path: str = parameter()\n\n    username: str =  parameter(\"admin\")        # default is \"admin\"\n    password: str = parameter(\"admin\")\n    service_name: str = parameter(\"postgres\")  # default is \"postgres\"\n    database_name: str = parameter(\"pgdata\")   # detault is \"pgdata\"\n\n    @computed_parameter\n    def port(self) -&gt; int:  # used to evaluate parameters lazily\n        return 5432\n</code></pre> <p>Then in the top-level <code>__init__.py</code> file we would have</p> <pre><code># vendorless.postgres.__init__.py\nfrom .service_templates import PostGreSQLDatabase\n</code></pre> <p>This way, dependent packages have nicely formatted import statements like so:</p> <pre><code>from vendorless.postgres import PostGreSQLDatabase\n</code></pre>"},{"location":"creating-packages/#commands","title":"Commands","text":"<p>The <code>vl</code> command-line tool uses Click. If you want to add any commands to your package, you should implement them in <code>vendorless.&lt;package&gt;.commands.py</code> using <code>@cli.group()</code>. For example:</p> <pre><code># vendorless.&lt;package&gt;.commands.py\n\n# (...)\n\n@cli.group()\n@click.argument('message', type=click.STRING)\ndef echo(message: str):\n    click.echo(message)\n</code></pre>"},{"location":"rendering-blueprints/","title":"Rendering Blueprints","text":"<p>A blueprint is a Python module that can be rendered to Docker Compose files that run an application. We won't get into the details of a blueprint's .py file here, but it simply configures service templates to stand up all of the services that are needed to run the application.</p> <p>This page will render a Keycloak authentation server as an example.  The general workflow is the same for rendering a blueprint other packages.</p>"},{"location":"rendering-blueprints/#step-1-install-packages","title":"Step 1: Install Packages","text":"<p>Install the package that provides the blueprint that you want to render. <pre><code>$ pip install vendorless-keycloak\n</code></pre></p>"},{"location":"rendering-blueprints/#step-2-render-the-blueprint","title":"Step 2: Render the Blueprint","text":"<p>Run the <code>vl core render</code> command to render a blueprint to Docker Compose files. Generally, vendorless packages provide blueprints at <code>vendorless.&lt;package&gt;.blueprints.&lt;app_name&gt;</code> so the command usually has the form: </p> <pre><code>vl core render -m vendorless.&lt;package&gt;.blueprints.&lt;app_name&gt;\n</code></pre> <p>For our keycloak authentication server the command would be:</p> <pre><code>$ vl core render -m vendorless.keycloak.blueprints.auth_server\n</code></pre> <p>Rendering A Blueprint From A Local File</p> <p>You can render blueprints from a local .py file like so:</p> <pre><code>$ vl core render ./path/to/blueprint.py\n</code></pre> <p>Your current working directory should now have a subdirectory with the rendered Docker Compose files.</p> <pre><code>./\n\u2514\u2500\u2500 vendorless.keycloak.blueprints.auth_server/\n    \u2514\u2500\u2500 docker-compose.yaml\n</code></pre>"},{"location":"rendering-blueprints/#step-3-start-the-application","title":"Step 3: Start The Application","text":"<p>Launch the application using Docker Compose.</p> <pre><code>$ cd vendorless.keycloak.blueprints.auth_server/\n$ docker compose up\n</code></pre>"},{"location":"volumes/","title":"Volumes","text":""},{"location":"volumes/#vendorless.core.Volume","title":"<code>vendorless.core.Volume</code>","text":"<p>               Bases: <code>ServiceTemplate</code></p> <p>Represents a Docker volume configuration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the Docker volume.</p> Source code in <code>src/vendorless/core/volume.py</code> <pre><code>@dataclass\nclass Volume(ServiceTemplate):\n    \"\"\"\n    Represents a Docker volume configuration.\n    \"\"\"\n\n    name: str = parameter()\n    \"\"\"The name of the Docker volume.\"\"\"\n\n    def _template_list(self) -&gt; list[tuple[str, str]]:\n        return [\n            ('volume/docker-compose.yaml', 'docker-compose.yaml')\n        ]\n</code></pre>"},{"location":"volumes/#vendorless.core.Volume.name","title":"<code>name = parameter()</code>","text":"<p>The name of the Docker volume.</p>"}]}